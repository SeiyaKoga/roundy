{"version":3,"file":"roundy.cjs.production.min.js","sources":["../src/Style.tsx","../src/utils.ts","../src/index.tsx"],"sourcesContent":["import styled from 'styled-components';\n\nconst Style = styled.div`\n  display: inline-block;\n  position: absolute;\n  width: 210px;\n  height: 210px;\n  @media screen and (min-width: 768px) {\n    height: 310px;\n    width: 310px;\n  }\n  top: -10px;\n  svg path {\n    opacity: 0.7;\n  }\n  .sliderHandle {\n    width: 50%;\n    pointer-events: all;\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    transform-origin: 0 50%;\n    &:after {\n      content: '';\n      display: block;\n      width: 15px;\n      height: 15px;\n      border-radius: 30px;\n      position: absolute;\n      right: -5px;\n      background: linear-gradient(to top, #fff, #f2f2f2);\n      border: 1px solid #ccc;\n      top: -10px;\n      transform: all ease 0.4s;\n    }\n    &:hover:after {\n      box-shadow: 0 0 10px rgb(37, 205, 247);\n    }\n  }\n  ${({ overrideStyle }) => overrideStyle}\n`;\nexport default Style;\n","import { InternalRoundyProps } from \"types\";\n\nconst DEGREE_IN_RADIANS = Math.PI / 180;\n\nexport const valueToAngle = (value: number = 0, props: InternalRoundyProps) => {\n  const { max, min, arcSize } = props;\n  const angle = ((value - min) / (max - min)) * arcSize;\n  return angle;\n};\n\nexport const getArc = (\n  startAngle: number,\n  endAngle: number,\n  props: InternalRoundyProps\n) => {\n  let { radius, strokeWidth } = props;\n  const pathRadius = radius - strokeWidth / 2;\n  const start = polarToCartesian(pathRadius, startAngle, radius);\n  const end = polarToCartesian(pathRadius, endAngle, radius);\n  const largeArcFlag = startAngle <= 180 ? 0 : 1;\n  return `M ${start} A ${pathRadius} ${pathRadius} 0 ${largeArcFlag} 0 ${end}`;\n};\n\nconst polarToCartesian = (\n  pathRadius: number,\n  angle: number,\n  radius: number\n) => {\n  const angleInRadians = (angle - 180) * DEGREE_IN_RADIANS;\n\n  const x = radius + pathRadius * Math.cos(angleInRadians);\n  const y = radius + pathRadius * Math.sin(angleInRadians);\n\n  return x + ' ' + y;\n};\n\nexport const getCenter = (\n  node: React.MutableRefObject<HTMLDivElement>,\n  radius: number\n) => {\n  var rect = node.current.getBoundingClientRect();\n  return {\n    top: rect.top + radius,\n    left: rect.left + radius,\n  };\n};\n\nexport const limitValue = (value: number, min: number, max: number) => {\n  if (value < min) value = min;\n  if (value > max) value = max;\n  return value;\n};\n\nconst radToDeg = (rad: number) => {\n  return rad * (180 / Math.PI);\n};\n\nexport const getAngle = (y: number, x: number, rotationOffset: number) => {\n  let angle = radToDeg(Math.atan2(y, x)) + 180 - rotationOffset;\n  if (angle > 360) {\n    angle = angle - 360;\n  }\n  if (angle < 0) {\n    angle = 360 + angle;\n  }\n  return angle;\n};\n\nexport const angleToValue = (angle: number, props: InternalRoundyProps) => {\n  const { min, max, arcSize } = props;\n  const v = (angle / arcSize) * (max - min) + min;\n  return v;\n};","import * as React from 'react';\nimport { useDrag } from 'react-use-gesture';\nimport hexoid from 'hexoid';\nimport Style from './Style';\nimport { InternalRoundyProps } from 'types';\nimport {\n  valueToAngle,\n  getCenter,\n  getAngle,\n  angleToValue,\n  limitValue,\n  getArc,\n} from './utils';\n\nconst classNamePrefix = 'RoundSlider';\n\nconst defaultProps: InternalRoundyProps = {\n  color: 'purple',\n  bgColor: '#ccc',\n  max: 100,\n  min: 0,\n  stepSize: 0,\n  // by default we want smooth sliding\n  steps: 0,\n  sliced: true,\n  strokeWidth: 4,\n  rotationOffset: 0,\n  arcSize: 360,\n  value: 50,\n  radius: 105,\n};\n\ninterface StateType {\n  value: number;\n  angle: number;\n}\n\nexport type MainRoundyProps = Partial<InternalRoundyProps> & {\n  render?: (state: StateType, props: InternalRoundyProps) => React.ReactNode;\n  onAfterChange?: (state: any, props: any) => void;\n  onChange?: (state: any, props: any) => void;\n  style?: any;\n  allowClick?: boolean;\n};\n\nfunction Roundy(optProps: MainRoundyProps) {\n  const props = { ...defaultProps, ...optProps };\n  const uniqueId = hexoid(7)();\n  const {\n    color,\n    bgColor,\n    max,\n    min,\n    steps,\n    stepSize,\n    strokeWidth,\n    radius,\n    sliced,\n    style,\n    arcSize,\n    rotationOffset,\n    onAfterChange,\n    allowClick,\n    render,\n    onChange,\n  } = props;\n\n  const _wrapper = React.useRef(null);\n  const _handle = React.useRef(null);\n  const isDrag = React.useRef(false);\n\n  const [state, setAll] = React.useState<StateType>({\n    value: props.value,\n    angle: valueToAngle(props.value, props),\n  });\n\n  const bind = useDrag(({ down, xy: [x, y] }) => {\n    setValueAndAngle(\n      x,\n      y,\n      !down\n        ? newState => {\n            isDrag.current = down;\n            onAfterChange && onAfterChange(newState, props);\n          }\n        : undefined\n    );\n  });\n\n  React.useEffect(() => {\n    if (props.value !== state.value) {\n      const newState = {\n        value: props.value,\n        angle: valueToAngle(props.value, props),\n      };\n      setAll(newState);\n    }\n  }, [props.value]);\n\n  const setState = (obj: Partial<StateType>) =>\n    setAll(prev => ({ ...prev, ...obj }));\n  const { angle } = state;\n  const segments = steps || (stepSize ? Math.floor((max - min) / stepSize) : 0);\n  const maskName = `${classNamePrefix}_${uniqueId}`;\n  const size = radius * 2;\n  const styleRotation = {\n    transform: `rotate(${rotationOffset}deg)`,\n    transformOrigin: '50% 50%',\n  };\n\n  const setValueAndAngle = (\n    x: number,\n    y: number,\n    cb?: (newState: StateType) => void\n  ) => {\n    const { left, top } = getCenter(_wrapper, radius);\n    const dX = x - left;\n    const dY = y - top;\n    const { value, angle } = stepRounding(getAngle(dY, dX, rotationOffset));\n    const newState = { value, angle };\n    setState(newState);\n    if (cb) {\n      cb(newState);\n    }\n    onChange && onChange(value, props);\n  };\n\n  const updateOnClick = event => {\n    if (isDrag.current) {\n      return;\n    }\n    const { clientX, clientY } = event;\n    let eX = clientX,\n      eY = clientY;\n\n    eX = clientX;\n    eY = clientY;\n    setValueAndAngle(eX, eY, newState => {\n      onAfterChange && onAfterChange(newState, props);\n    });\n  };\n\n  const getMaskLine = (segments: number, index: number) => {\n    const { radius, arcSize } = props;\n    const val = (arcSize / segments) * index + 180;\n    const rotateFunction =\n      'rotate(' + val.toString() + ',' + radius + ',' + radius + ')';\n    return (\n      <g key={index} transform={rotateFunction}>\n        <line\n          x1={radius}\n          y1={radius}\n          x2={radius * 2}\n          y2={radius}\n          style={{\n            stroke: 'rgb(0,0,0)',\n            strokeWidth: 2,\n          }}\n        />\n      </g>\n    );\n  };\n\n  const stepRounding = (degree: number) => {\n    const { stepSize, steps, min, max, arcSize } = props;\n    const step = stepSize || (steps ? (max - min) / steps : 1);\n    const { angle: oldAngle } = state;\n    let angToValue = min;\n    if (!isDrag.current) {\n      angToValue = angleToValue(degree, props);\n    } else {\n      angToValue = angleToValue(\n        oldAngle > arcSize - 20 && degree < arcSize / 4\n          ? Math.max(degree, arcSize)\n          : oldAngle < 20 && degree > arcSize - 20\n          ? Math.min(degree, 0)\n          : degree,\n        props\n      );\n    }\n    let value;\n    const remain = (angToValue - min) % step;\n    const currVal = angToValue - remain;\n    const nextVal = limitValue(currVal + step, min, max);\n    const preVal = limitValue(currVal - step, min, max);\n    if (angToValue >= currVal)\n      value = angToValue - currVal < nextVal - angToValue ? currVal : nextVal;\n    else {\n      value = currVal - angToValue > angToValue - preVal ? currVal : preVal;\n    }\n    value = Math.round(value);\n    const ang = valueToAngle(value, props);\n    return { value, angle: ang };\n  };\n  return (\n    <Style\n      className=\"roundy\"\n      onClick={updateOnClick}\n      style={\n        allowClick || render\n          ? style\n          : { ...(style || {}), pointerEvents: 'none' }\n      }\n    >\n      {render ? (\n        <div\n          className=\"roundyRenderPropsParent\"\n          ref={_wrapper}\n          {...bind()}\n          style={{ width: size, height: size, display: 'inline-block' }}\n        >\n          {render(state, props)}\n        </div>\n      ) : (\n        <React.Fragment>\n          <svg ref={_wrapper} width={size} height={size}>\n            {sliced && (\n              <defs>\n                <mask\n                  id={maskName}\n                  maskUnits=\"userSpaceOnUse\"\n                  style={styleRotation}\n                >\n                  <rect x={0} y={0} width={size} height={size} fill=\"white\" />\n                  {Array.from({ length: segments }).map((_, i) => {\n                    return getMaskLine(segments, i);\n                  })}\n                </mask>\n              </defs>\n            )}\n\n            <path\n              fill=\"transparent\"\n              strokeDashoffset=\"0\"\n              strokeWidth={strokeWidth}\n              stroke={bgColor}\n              mask={sliced ? `url(#${maskName})` : undefined}\n              style={styleRotation}\n              d={getArc(Math.min(arcSize, 359.9999), 0, props)}\n            />\n            <path\n              fill=\"none\"\n              strokeWidth={strokeWidth}\n              stroke={color}\n              mask={sliced ? `url(#${maskName})` : undefined}\n              style={styleRotation}\n              d={getArc(Math.min(angle, 359.9999), 0, props)}\n            />\n          </svg>\n          <div\n            ref={_handle}\n            className=\"sliderHandle\"\n            {...bind()}\n            style={{\n              transform: `rotate(${angle + rotationOffset}deg) scaleX(-1)`,\n            }}\n          />\n        </React.Fragment>\n      )}\n    </Style>\n  );\n}\n\nexport default Roundy;\n"],"names":["Style","div","overrideStyle","DEGREE_IN_RADIANS","Math","PI","valueToAngle","value","props","min","max","arcSize","getArc","startAngle","endAngle","radius","pathRadius","strokeWidth","polarToCartesian","angle","angleInRadians","cos","sin","limitValue","defaultProps","color","bgColor","stepSize","steps","sliced","rotationOffset","optProps","uniqueId","hexoid","style","onAfterChange","allowClick","render","onChange","_wrapper","React","_handle","isDrag","state","setAll","bind","useDrag","down","xy","setValueAndAngle","undefined","newState","current","segments","floor","maskName","classNamePrefix","size","styleRotation","transform","transformOrigin","x","y","cb","obj","node","rect","getBoundingClientRect","top","left","getCenter","stepRounding","atan2","getAngle","prev","degree","angToValue","step","oldAngle","currVal","angleToValue","nextVal","preVal","round","className","onClick","event","clientX","clientY","pointerEvents","ref","width","height","display","id","maskUnits","fill","Array","from","length","map","_","i","index","rotateFunction","toString","key","x1","y1","x2","y2","stroke","getMaskLine","strokeDashoffset","mask","d"],"mappings":"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"}